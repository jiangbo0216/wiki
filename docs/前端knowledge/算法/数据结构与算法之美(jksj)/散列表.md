## 散列表

散列表用的是数组支持按照下标访问数据的特性, 所以散列表其实是数组的一种扩展.

通过hash函数编码键值为索引, 类比数组的索引

### 散列冲突

#### 开放寻址法

如果出现冲突, 重新探测一个空闲位置, 将其插入.  
如何探测新的位置, 简单的我们可以使用

* 线性探测(Linear Probing)
* 二次探测
* 双重散列

衡量空位的多少: 装载因子: 填入表中的元素个数 / 散列表的长度

#### 链表法

## 应用

单词拼写检查(一个字母占用一个字节的空间)

常用的英文单词有20w左右, 假设单词的长度是10个字母, 平均一个单词占用10个字节的内存空间, 20w个单词大约占用2MB的存储空间, 即使是20MB, 这个大小完全可以放入内存之中

所以我们可以用散列表来存储整个英文单词词典

### 如何满足工业级的要求

#### 散列表碰撞攻击基本原理

极端情况下, 恶意攻击者通过进行构造数据, 使得所有的数据通过hash函数之后, 都散列再同一个槽里, 这个时候散列表退化成了链表, 查询的时间复杂度就从O(1)退化为O(n)
假如有10w条数据, 查询的效率下降了10w倍, 原来0.1s需要1w秒, 有可能因为查询操作消耗大量的CPU或者线程资源, 导致系统无法响应其他请求, 从而达到拒绝服务攻击的目的(Dos)

#### 设计hash函数

* 不能太复杂, 过于复杂消耗cpu
* 计算结果尽可能随机并且均匀分布

#### 高效扩容

将一次性扩容的代价，均摊到多次插入操作中，就避免了一次性扩容耗时过多的情况

#### 如何选择冲突解决方法

链表法包含指针，序列化起来就没那么容易。

1. 开放寻址法 (数据量比较小的时候, 适合采用开放寻址法)
2. 链表法 (链表结点可以再需要的时候创建, 不需要像开放寻址法事先申请空间, 存储大对象)
   1. 对于大装载银子容忍度更高
   2. 链表可以改造成例如跳表, 红黑树等数据结构, 即使出现hash冲突, 查找时间增长到O(logn)

## 散列表和链表

散列表这种数据结构虽然支持非常高效的数据插入, 删除, 查找操作, 但是散列表中的数据都是通过hash函数打乱之后无规律存储的, 无法支持按照某种顺序快速遍历数据结构
