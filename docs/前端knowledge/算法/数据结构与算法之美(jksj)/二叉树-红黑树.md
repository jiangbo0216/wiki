# 二叉树

* 二叉树有那几家中存储方式
* 什么样的二叉树适合用数组来存储

## 树中有关概念

* 高度(低到高, 下到上, 从0开始, 边数)
* 深度(高到低, 上到下, 从零开始, 边数)
* 层数: 深度 + 1

* 满二叉树
* 完全二叉树 (适合基于数组的顺序存储法)

## 两种存储方法

* 基于指针或引用
* 基于数组的顺序存储法(举例一种存储方法, i表示, 2*i存储左子节点, 2*i+1 存储右子节点, i/2 位置存储父节点)
  * 堆其实就是一种完全二叉树，最常用的存储方式就是数组

### 遍历

前序遍历的递推公式：
preOrder(r) = print r->preOrder(r->left)->preOrder(r->right)

中序遍历的递推公式：
inOrder(r) = inOrder(r->left)->print r->inOrder(r->right)

后序遍历的递推公式：
postOrder(r) = postOrder(r->left)->postOrder(r->right)->print r

有了递推公式，代码写起来就简单多了。这三种遍历方式的代码，我都写出来了，你可以看看。

void preOrder(Node*root) {
 if (root == null) return;
 print root // 此处为伪代码，表示打印root节点
 preOrder(root->left);
 preOrder(root->right);
}

void inOrder(Node* root) {
 if (root == null) return;
 inOrder(root->left);
 print root // 此处为伪代码，表示打印root节点
 inOrder(root->right);
}

void postOrder(Node* root) {
 if (root == null) return;
 postOrder(root->left);
 postOrder(root->right);
 print root // 此处为伪代码，表示打印root节点
}

两种存储方法都可以做到

## 散列表对比二叉树

我们在散列表那节中讲过，散列表的插入、删除、查找操作的时间复杂度可以做到常量级的O(1)，非常高效。而二叉查找树在比较平衡的情况下，插入、删除、
查找操作时间复杂度才是O(logn)，相对散列表，好像并没有什么优势，那我们为什么还要用二叉查找树呢？
我认为有下面几个原因：
第一，散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，我们只需要中序遍历，就可以在O(n)的时间复杂度
内，输出有序的数据序列。
第二，散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，我们最常用的平衡二叉查找树的性能非常稳
定，时间复杂度稳定在O(logn)。
第三，笼统地来说，尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比logn小，所以实际的查找速度可能不一定
比O(logn)快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。
第四，散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一
个问题，而且这个问题的解决方案比较成熟、固定。
最后，为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间。
综合这几点，平衡二叉查找树在某些方面还是优于散列表的，所以，这两者的存在并不冲突。我们在实际的开发过程中，需要结合具体的需求来选择使用哪一
个。

## 红黑树 (平衡二叉树)

### 定义

节点一类被标记为黑色，一类被标记为红色

1. 根节点黑色
2. 叶子节点黑色Nil节点
3. 任何相邻的节点不能同时为红色, 必须被隔开
4. 每个节点, 从该节点到达叶子节点的所有路径, 黑色节点相同

平衡二叉树基本定义:  
任何节点的左右子树高度相差 <= 1

比较平衡:  
如果我们现在设计一个新的平衡二叉查找树，只要树的高度不比log2n大很多（比如树的高度仍然是对数量级的），尽管它不符合我们前面讲的严格的平衡
二叉查找树的定义，但我们仍然可以说，这是一个合格的平衡二叉查找树。

### 红黑树高度推导

1. 当去掉所有的红色节点, 原本红色节点的黑色子节点以被移除的红色的父节点作为父节点. 二叉树变成四叉树, 此时黑色四叉树的高度小于同样节点数的完全二叉树, < logn
2. 加上所有的红色节点, 最长路径不会超过 2logn

红黑树只是做到了近似平衡，并不是严格的平衡，所以在维护平衡的成本上，要比AVL树要低。