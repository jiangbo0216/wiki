浮点数加减法步骤：

1. 对阶
2. 尾数求和
3. 规格化
4. 舍入
5. 溢出判断

## [未知]如何判断 0.1 + 0.2 与 0.3 相等？(红白)

作为一道面试题，我觉得重要的是要讲出一点其他人一般不会答出来的深度。像这道题，可以从原理和解决方案两个地方作为答题点，最好在编一个案例。大致讲自己遇到过这个问题，于是很好奇深入研究了一下，发现是浮点数精度导致……原理怎样怎样……然后又看了业界的库的源码，然后怎样怎样解决。

关于原理，我专门写了一篇文章 [github.com/mqyqingfeng…](https://github.com/mqyqingfeng/Blog/issues/155) 来解释，实际回答的时候，我觉得答出来

1. 非是 ECMAScript 独有
2. IEEE754 标准中 64 位的储存格式，比如 11 位存偏移值
3. 其中涉及的三次精度丢失

就已经 OK 了。

再讲解决方案，这个可以直接搜索到，各种方案都了解一下，比较一下优劣，还可以参考业界的一些库的实现，比如 math.js，不过相关的我并没有看过……

如果还有精力的话，可以从加法再拓展讲讲超出安全值的数字的计算问题。

所以我觉得一能回答出底层实现，二能回答出多种解决方案的优劣，三能拓展讲讲 bignum 的处理，就是一个非常不错的回答了。

作者：冴羽
链接：<https://juejin.cn/post/6844904097556987917>
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

没想到在一家公司面试中遇到这个题，还好本人是在学习《你不知道的javaScript中卷》一书中看到这种方法，所以把他写下来，希望对刚好需要它的码友有一点点帮助。
怎么判断 0.1+0.2 和 0.3 是否相等?
最常见的就是设置一个误差范围值，通常称之为“及其精度”（machine epsilon）,对于 javaScript 来说，这个值通常是 2^-52(2.220446049250313e-16)。
该值定义在 ES6 Number.EPSILON 中，可以直接使用

function numberClose(num1,num2){
    return Math.abs(num1 - num2) < Number.EPSILON;
}
var first = 0.1 +0.2
var second = 0.3
numberClose(first,second) //true
numberClose(0.0000001,0.0000002) //false
————————————————
版权声明：本文为CSDN博主「weixin_47464657」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：<https://blog.csdn.net/weixin_47464657/article/details/106880318>
