https://juejin.im/post/5a6547d0f265da3e283a1df7#heading-15
进程是cpu资源分配的最小单位（系统会给它分配内存）

* 进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）

* 线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）

tips

* 不同进程之间也可以通信，不过代价较大

* 现在，一般通用的叫法：单线程与多线程，都是指在一个进程内的单和多。（所以核心还是得属于一个进程才行）

## 浏览器是多进程的
理解了进程与线程了区别后，接下来对浏览器进行一定程度上的认识：（先看下简化理解）


* 浏览器是多进程的


* 浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存）


* 简单点理解，每打开一个Tab页，就相当于创建了一个独立的浏览器进程。(每一个tab标签对应一个进程不是绝对的)

## 浏览器都包含哪些进程？
知道了浏览器是多进程后，再来看看它到底包含哪些进程：（为了简化理解，仅列举主要进程）


1. Browser进程：浏览器的主进程（负责协调、主控），只有一个。作用有


   1. 负责浏览器界面显示，与用户交互。如前进，后退等


   2. 负责各个页面的管理，创建和销毁其他进程


   3. 将Renderer进程得到的内存中的Bitmap，绘制到用户界面上


   4. 网络资源的管理，下载等




2. 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建


3. GPU进程：最多一个，用于3D绘制等


4. 浏览器渲染进程（浏览器内核）（Renderer进程，内部是多线程的）：默认每个Tab页面一个进程，互不影响。主要作用为

   1. 页面渲染，脚本执行，事件处理等



强化记忆：在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程）
当然，浏览器有时会将多个进程合并（譬如打开多个空白标签页后，会发现多个空白标签页被合并成了一个进程），如图
![20191216114411.png](https://raw.githubusercontent.com/jiangbo0216/wiki/pic-bed/20191216114411.png)

浏览器多进程的优势
相比于单进程浏览器，多进程有如下优点：


* 避免单个page crash影响整个浏览器


* 避免第三方插件crash影响整个浏览器


* 多进程充分利用多核优势


* 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性


简单点理解：如果浏览器是单进程，那么某个Tab页崩溃了，就影响了整个浏览器，体验有多差；同理如果是单进程，插件崩溃了也会影响整个浏览器；而且多进程还有其它的诸多优势。。。
当然，内存等资源消耗也会更大，有点空间换时间的意思。



## 重点是浏览器内核（渲染进程）
重点来了，我们可以看到，上面提到了这么多的进程，那么，对于普通的前端操作来说，最终要的是什么呢？答案是渲染进程
可以这样理解，页面的渲染，JS的执行，事件的循环，都在这个进程内进行。接下来重点分析这个进程
请牢记，浏览器的渲染进程是多线程的（这点如果不理解，请回头看进程和线程的区分）
终于到了线程这个概念了😭，好亲切。那么接下来看看它都包含了哪些线程（列举一些主要常驻线程）：


1. GUI渲染线程


   1. 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。


   2. 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行


   3. 注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。




2. JS引擎线程


   1. 也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）


   2. JS引擎线程负责解析Javascript脚本，运行代码。


   3. JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序


   4. 同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。




3. 事件触发线程


   1. 归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）


   2. 当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中


   3.  当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理


   4.  注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）




4.  定时触发器线程


    1.  传说中的setInterval与setTimeout所在线程


    2.  浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）


    3.  因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）


    4.  注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。




5.  异步http请求线程


  6.  在XMLHttpRequest在连接后是通过浏览器新开一个线程请求


  7.  将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。




看到这里，如果觉得累了，可以先休息下，这些概念需要被消化，毕竟后续将提到的事件循环机制就是基于事件触发线程的，所以如果仅仅是看某个碎片化知识，
可能会有一种似懂非懂的感觉。要完成的梳理一遍才能快速沉淀，不易遗忘。放张图巩固下吧：

![20191216115251.png](https://raw.githubusercontent.com/jiangbo0216/wiki/pic-bed/20191216115251.png)

## Browser进程和浏览器内核（Renderer进程）的通信过程
看到这里，首先，应该对浏览器内的进程和线程都有一定理解了，那么接下来，再谈谈浏览器的Browser进程（控制进程）是如何和内核通信的，
这点也理解后，就可以将这部分的知识串联起来，从头到尾有一个完整的概念。
如果自己打开任务管理器，然后打开一个浏览器，就可以看到：任务管理器中出现了两个进程（一个是主控进程，一个则是打开Tab页的渲染进程），
然后在这前提下，看下整个的过程：(简化了很多)


Browser进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过RendererHost接口传递给Render进程


Renderer进程的Renderer接口收到消息，简单解释后，交给渲染线程，然后开始渲染


渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染


当然可能会有JS线程操作DOM（这样可能会造成回流并重绘）


最后Render进程将结果传递给Browser进程




Browser进程接收到结果并将结果绘制出来


这里绘一张简单的图：（很简化）
![20191216115639.png](https://raw.githubusercontent.com/jiangbo0216/wiki/pic-bed/20191216115639.png)
看完这一整套流程，应该对浏览器的运作有了一定理解了，这样有了知识架构的基础后，后续就方便往上填充内容。
这块再往深处讲的话就涉及到浏览器内核源码解析了，不属于本文范围。
如果这一块要深挖，建议去读一些浏览器内核源码解析文章，或者可以先看看参考下来源中的第一篇文章，写的不错
